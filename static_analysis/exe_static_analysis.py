import os
import re
import json
import pefile
import zipfile
import subprocess
import pandas as pd
import glob
import ipaddress

class ExeStaticAnalysis:
    def __init__(self):
        results = {}
        self.packer_signatures = [
            {"signature": b'UPX\x00\x01\xF0\x88\xE2\xFA', "name": "UPX"},
            {"signature": b'nullsoft install system', "name": "NSIS"},
            {"signature": b'PECompact', "name": "PECompact"},
            {"signature": b'ASPack', "name": "ASPack"},
            {"signature": b'FSG!', "name": "FSG"},
            {"signature": b'tElock', "name": "tElock"},
            {"signature": b'Themida', "name": "Themida"},
            {"signature": b'ASProtect', "name": "ASProtect"},
        ]
        self.extracted_strings_dir = 'extracted_strings'
    def _detect_packer(self, pe):
        for signature in self.packer_signatures:
            if signature in pe.__data__:
                return {'name': signature['name'], 'signature': signature.decode('utf-8')}
        return None
    def _extract_file_paths(self, text):
        file_path_pattern = r'([a-zA-Z]:)?\\(?:[^\0\\/:*?"<>|\r\n]+\\)*[^\0\\/:*?"<>|\r\n]*'
        file_paths = re.findall(file_path_pattern, text)

        unique_path_counts = {}
        for path in file_paths:
            cleaned_path = path.strip()
            if cleaned_path:
                unique_path_counts[cleaned_path] = unique_path_counts.get(cleaned_path, 0) + 1

        return unique_path_counts
    def _extract_exe_strings(self, text):
        exe_pattern = r'\b\w+\.exe\b'
        exe_calls = re.findall(exe_pattern, text, re.IGNORECASE)
        
        unique_exe_calls = {}
        for exe_call in exe_calls:
            cleaned_exe_call = exe_call.lower()  # Convert to lowercase for case-insensitive matching
            unique_exe_calls[cleaned_exe_call] = unique_exe_calls.get(cleaned_exe_call, 0) + 1

        total = 0
        for call in unique_exe_calls:
            total += unique_exe_calls[call]
        calls = {
            'count': total,
            'calls':unique_exe_calls
        }
        return calls

    def _extract_imported_functions(self, pe):
        imported_functions = {}
        for entry in pe.DIRECTORY_ENTRY_IMPORT:
            for imp in entry.imports:
                if imp.name is not None:
                    api_name = imp.name.decode('utf-8')
                    imported_functions[api_name] = imported_functions.get(api_name, 0) + 1
        return imported_functions
    def _extract_pe_header_info(self, file_path):
        pe_info = {}
        try:
            pe = pefile.PE(file_path)
            pe_info['Machine'] = hex(pe.FILE_HEADER.Machine)
            pe_info['NumberOfSections'] = pe.FILE_HEADER.NumberOfSections
            pe_info['TimeDateStamp'] = pe.FILE_HEADER.TimeDateStamp
            pe_info['ImageBase'] = hex(pe.OPTIONAL_HEADER.ImageBase)
            pe_info['SizeOfHeaders'] = pe.OPTIONAL_HEADER.SizeOfHeaders
            pe_info['Characteristics'] = hex(pe.FILE_HEADER.Characteristics)
            
            imported_functions = self._extract_imported_functions(pe)
            pe_info['imported_functions'] = {
                'count':len(imported_functions),
                'functions':imported_functions
            }
            detected_packer = self._detect_packer(pe)
            if detected_packer:
                pe_info['suspicious_packer'] = True
            else:
                pe_info['suspicious_packer'] = False

        except Exception as e:
            print(f"Error extracting PE header info: {e}")
        return pe_info
    def _extract_dll_strings(self, text):
        dll_pattern = r'\b\w+\.dll\b'
        dll_calls = re.findall(dll_pattern, text, re.IGNORECASE)
        
        unique_dll_calls = {}
        for dll_call in dll_calls:
            cleaned_dll_call = dll_call.lower()  # Convert to lowercase for case-insensitive matching
            unique_dll_calls[cleaned_dll_call] = unique_dll_calls.get(cleaned_dll_call, 0) + 1
        
        total = 0
        for call in unique_dll_calls:
            total += unique_dll_calls[call]
        calls = {
            'count': total,
            'calls':unique_dll_calls
        }
        return calls

    def _extract_ip_addresses(self, text):
        ip_pattern = r'\b(?:\d{1,3}\.){3}\d{1,3}\b'
        ip_addresses = re.findall(ip_pattern, text)

        unique_ip_counts = {}
        for ip in ip_addresses:
            try:
                ip_obj = ipaddress.ip_address(ip)
                if not ip_obj.is_reserved and not ip_obj.is_private:
                    unique_ip_counts[ip] = unique_ip_counts.get(ip, 0) + 1
            except ValueError:
                pass  # Invalid IP address, skip

        total = 0
        for ip in unique_ip_counts:
            total += unique_ip_counts[ip]
        ips = {
            'count': total,
            'addresses':unique_ip_counts
        }
        return ips
    
    def _extract_urls(self, text):
        url_pattern = r'https?://\S+|www\.\S+'
        urls = re.findall(url_pattern, text)
        url_dict = {
            'count':len(urls),
            'urls':urls
        }
        return url_dict


    def _load_strings_from_file(self, file_path):
        try:
            with open(file_path, 'r') as f:
                return f.read()
        except Exception as e:
            print(f"Error loading strings from file: {e}")
            return ""

    def _run_strings(self, input_file, output_file):
        cmd = ["strings", input_file]
        try:
            result = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, check=True)
            with open(output_file, "w") as f:
                f.write(result.stdout)
            print(f"Extracted strings from '{input_file}' to '{output_file}'")
        except subprocess.CalledProcessError:
            print(f"Failed to extract strings from '{input_file}'")

    def static_analysis(self, file_path, hash_value):
        
        strings_file = os.path.join(self.extracted_strings_dir, f'{hash_value}.txt')
        
        if os.path.exists(strings_file):
            strings_output = self._load_strings_from_file(strings_file)
        else:
            strings_output = self._run_strings(file_path, strings_file)
        text = strings_output
        result = {
            'ip_addresses': self._extract_ip_addresses(text),
            'urls': self._extract_urls(text),
            'dll_strings': self._extract_dll_strings(text),
            'exe_strings':self._extract_exe_strings(text),
            #'file_paths': self._extract_file_paths(text)
        }
        # result['exe_strings'] = len(result['exe_strings'])
        # result['ip_addresses'] = len(result['ip_addresses'])

        if file_path.endswith('.exe'):
            pe_header_info = self._extract_pe_header_info(file_path)
            result['header'] = pe_header_info
        elif file_path.endswith('.jar'):
            jar_header_info = self._extract_jar_header_info(file_path)
            result['header'] = jar_header_info
        
        return result